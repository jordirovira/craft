#pragma once

#include "platform.h"
#include "axe.h"

#include <string>
#include <vector>
#include <memory>


//! Dynamic link library import and export
//! define CRAFTCOREI_BUILD when building the dynamic library
#if _MSC_VER

    #ifdef CRAFTCOREI_BUILD
        #define CRAFTCOREI_API __declspec(dllexport)
    #else
        #define CRAFTCOREI_API __declspec(dllimport)
    #endif

#else

    #define CRAFTCOREI_API

#endif


extern void craft_core_initialize( axe::Kernel* log_kernel=nullptr );

class Toolchain;
class Context;
class Node;
typedef std::vector< std::shared_ptr<Node> > NodeList;
class Target;
typedef std::vector< std::shared_ptr<Target> > TargetList;



class Node
{
public:
    std::string m_absolutePath;
};


//! Tasks created by the targets
class Task
{
public:
    Task( const std::string& type, const NodeList& outputs, std::function<void()> run )
        : m_type(type)
        , m_outputs(outputs)
        , m_runMethod(run)
    {
    }

    Task( const std::string& type, std::shared_ptr<Node>& output, std::function<void()> run )
        : m_type(type)
        , m_runMethod(run)
    {
        m_outputs.push_back(output);
    }

    std::string m_type;
    NodeList m_outputs;
    std::function<void()> m_runMethod;
    std::vector<std::shared_ptr<Task>> m_requirements;
};


//!
class Target
{
public:

    // Definition
    CRAFTCOREI_API Target& source( const std::string& files );
    CRAFTCOREI_API Target& include( const std::string& paths );
    CRAFTCOREI_API Target& use( const std::string& files );
    CRAFTCOREI_API Target& export_include( const std::string& files );
    CRAFTCOREI_API Target& export_library_options( const std::string& options );
    CRAFTCOREI_API Target& library_path( const std::string& path );
    CRAFTCOREI_API Target& is_default( bool enabled=true );

    // Operation
    CRAFTCOREI_API virtual std::shared_ptr<class BuiltTarget> build( Context& ctx ) = 0;

    std::string m_name;

    //!
    bool m_is_default = false;

    //! Source files required to build this target
    std::vector<std::string> m_sources;

    //! Include directories required to build this target
    std::vector<std::string> m_includes;

    //! Other targets whose output is used to build this target
    std::vector<std::string> m_uses;

    //! Include directories required to build those targets that use this target
    std::vector<std::string> m_export_includes;
    std::vector<std::string> m_export_library_options;
    std::string m_library_path;
};


class BuiltTarget
{
public:

    //! Source target used to build this one
    std::shared_ptr<Target> m_sourceTarget;

    //! List of output tasks generated by the target's build process.
    //! It may be empty if the output node was up to date.
    std::vector<std::shared_ptr<Task>> m_outputTasks;

    //! Node produced by this target build process
    std::shared_ptr<Node> m_outputNode;

};


class ExternDynamicLibraryTarget : public Target
{
public:

    // Operation
    virtual std::shared_ptr<BuiltTarget> build( Context& ) override;

};


class ObjectTarget : public Target
{
public:

    virtual std::shared_ptr<BuiltTarget> build( Context& ctx ) override;

    static std::shared_ptr<Task> object( Context& ctx, const std::string& name, const std::vector<std::string>& includePaths,
                                         std::shared_ptr<Node>& outputNode );

};


class CppTarget : public Target
{
public:

    virtual std::shared_ptr<BuiltTarget> build( Context& ctx ) override;

protected:
    virtual void link(Context& ctx, BuiltTarget &builtTarget, const NodeList& objects ) = 0;

};


class ProgramTarget : public CppTarget
{
protected:
    virtual void link(Context& ctx, BuiltTarget &builtTarget, const NodeList& objects ) override;
};


class StaticLibraryTarget : public CppTarget
{
protected:
    virtual void link(Context& ctx, BuiltTarget &builtTarget, const NodeList& objects ) override;
};


class DynamicLibraryTarget : public CppTarget
{
protected:
    virtual void link(Context& ctx, BuiltTarget &builtTarget, const NodeList& objects ) override;
};


class Version
{
public:

    CRAFTCOREI_API virtual const char* name() const;

};


class Context
{
public:

    CRAFTCOREI_API static std::shared_ptr<Context> Create( bool buildFolderHasHost=true,
                                                           bool buildFolderHasTarget=true );

    virtual ~Context() {}

    // Build configuration

    //! Set the folder used to store all build artifacts. By default is "build" from the current
    //! working folder.
    CRAFTCOREI_API virtual void set_build_folder( const std::string& folder ) = 0;

    // State query
    CRAFTCOREI_API virtual std::shared_ptr<Platform> get_host_platform() = 0;

    CRAFTCOREI_API virtual std::shared_ptr<Platform> get_current_target_platform() = 0;

    CRAFTCOREI_API virtual std::shared_ptr<Toolchain> get_current_toolchain() = 0;

    CRAFTCOREI_API virtual const std::string& get_current_path() = 0;

    CRAFTCOREI_API virtual std::shared_ptr<Target> get_target( const std::string& name ) = 0;
    CRAFTCOREI_API virtual std::shared_ptr<BuiltTarget> get_built_target( const std::string& name ) = 0;

    CRAFTCOREI_API virtual const TargetList& get_targets() = 0;
    CRAFTCOREI_API virtual TargetList get_default_targets() = 0;

    CRAFTCOREI_API virtual bool has_configuration( const std::string& name ) const = 0;

    // Execution control
    // \todo hide when defining targets in a craftfile
    CRAFTCOREI_API virtual void set_current_configuration( const std::string& name ) = 0;
    CRAFTCOREI_API virtual const std::string& get_current_configuration() const = 0;
    CRAFTCOREI_API virtual const std::vector<std::string>& get_default_configurations() const = 0;
    CRAFTCOREI_API virtual void run()=0;

    // Target definition
    CRAFTCOREI_API virtual std::shared_ptr<Node> file( const std::string& absolutePath ) = 0;

    CRAFTCOREI_API virtual Target& program( const std::string& name ) = 0;

    CRAFTCOREI_API virtual Target& static_library( const std::string& name ) = 0;

    CRAFTCOREI_API virtual DynamicLibraryTarget& dynamic_library( const std::string& name ) = 0;

    CRAFTCOREI_API virtual Target& extern_dynamic_library( const std::string& name ) = 0;

    CRAFTCOREI_API virtual Target& object( const std::string& name, const std::vector<std::string>& includePaths ) = 0;

    CRAFTCOREI_API virtual bool IsTargetOutdated( FileTime target_time, const NodeList& dependencies ) = 0;

protected:

    Context() {}


};

