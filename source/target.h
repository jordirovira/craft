#pragma once

#include "platform.h"
#include "axe.h"

#include <string>
#include <vector>
#include <memory>


class Toolchain;
class Context;
class ContextPlan;
class Node;
typedef std::vector< std::shared_ptr<Node> > NodeList;
typedef std::vector< std::shared_ptr<class Target_Base> > TargetList;


class Target_Base
{
public:

    // Operation
    CRAFTCOREI_API virtual std::shared_ptr<class BuiltTarget> build( ContextPlan& ctx ) = 0;

    // If the target may change across configuration options
    CRAFTCOREI_API virtual bool is_configuration_sensitive() const {return true;}

    std::string m_name;

    //! Other targets whose output is used to build this target
    std::vector<std::string> m_uses;

    //!
    bool m_is_default = false;
};


template<class TARGET_CLASS>
class Target_BaseDefinition : public Target_Base
{
public:

    // Definition
    TARGET_CLASS& use( const std::string& targets )
    {
        m_uses.push_back( targets );
        return static_cast<TARGET_CLASS&>(*this);
    }

    TARGET_CLASS& is_default( bool enabled=true )
    {
        m_is_default = enabled;
        return static_cast<TARGET_CLASS&>(*this);
    }
};

//!
class CppTarget : public Target_BaseDefinition<CppTarget>
{
public:

    // Definition
    CRAFTCOREI_API CppTarget& source( const std::string& files );
    CRAFTCOREI_API CppTarget& include( const std::string& paths );
    CRAFTCOREI_API CppTarget& export_include( const std::string& files );
    CRAFTCOREI_API CppTarget& export_library_options( const std::string& options );

    // Target interface
    virtual std::shared_ptr<BuiltTarget> build( ContextPlan& ctx ) override;

    //! Source files required to build this target
    std::vector<std::string> m_sources;

    //! Include directories required to build this target
    std::vector<std::string> m_includes;

    //! Include directories required to build those targets that use this target
    std::vector<std::string> m_export_includes;
    std::vector<std::string> m_export_library_options;

protected:
    virtual void link(ContextPlan& ctx, BuiltTarget &builtTarget, const NodeList& objects ) = 0;
};


//!
class BuiltTarget
{
public:
    virtual ~BuiltTarget() {}

    //! Source target used to build this one
    std::shared_ptr<Target_Base> m_sourceTarget;

    //! List of output tasks generated by the target's build process.
    //! It may be empty if the output node was up to date.
    std::vector<std::shared_ptr<class Task>> m_outputTasks;

    //! Node produced by this target build process
    std::shared_ptr<Node> m_outputNode;

    //!
    bool has_errors() const {return m_error;}

private:

    bool m_error = false;
};


class ExternDynamicLibraryTarget : public Target_BaseDefinition<ExternDynamicLibraryTarget>
{
public:

    // Definition
    CRAFTCOREI_API ExternDynamicLibraryTarget& library_path( const std::string& path );
    CRAFTCOREI_API ExternDynamicLibraryTarget& library_path( std::function<std::string(const ContextPlan&)> generator );
    CRAFTCOREI_API ExternDynamicLibraryTarget& export_include( const std::string& files );
    CRAFTCOREI_API ExternDynamicLibraryTarget& export_library_options( const std::string& options );

    // Operation
    class Built : public BuiltTarget
    {
    public:
        std::string m_library_path;
    };

    virtual std::shared_ptr<BuiltTarget> build( ContextPlan& ) override;

    //! Include directories required to build those targets that use this target
    std::vector<std::string> m_export_includes;
    std::vector<std::string> m_export_library_options;

    //!
    std::string get_library_path( const ContextPlan& ctx ) const;

private:

    std::string m_library_path;
    std::function<std::string(const ContextPlan& ctx)> m_library_path_generator;

};


class ObjectTarget : public Target_BaseDefinition<ObjectTarget>
{
public:

    virtual std::shared_ptr<BuiltTarget> build( ContextPlan& ctx ) override;

    static std::shared_ptr<Task> object( ContextPlan& ctx, const std::string& name, const std::vector<std::string>& includePaths,
                                         std::shared_ptr<Node>& outputNode );

    //! Include directories required to build this target
    std::vector<std::string> m_includes;

};


class ProgramTarget : public CppTarget
{
protected:
    virtual void link(ContextPlan& ctx, BuiltTarget &builtTarget, const NodeList& objects ) override;
};


class StaticLibraryTarget : public CppTarget
{
protected:
    virtual void link(ContextPlan& ctx, BuiltTarget &builtTarget, const NodeList& objects ) override;
};


class DynamicLibraryTarget : public CppTarget
{
protected:
    virtual void link(ContextPlan& ctx, BuiltTarget &builtTarget, const NodeList& objects ) override;
};


class DownloadTarget : public Target_BaseDefinition<DownloadTarget>
{
public:
    DownloadTarget& url(const std::string& url);

    // Target interface
    std::shared_ptr<class BuiltTarget> build( ContextPlan& ctx ) override;
    bool is_configuration_sensitive() const override {return false;}

private:
    std::string m_url;
};


class UnarchiveTarget : public Target_BaseDefinition<UnarchiveTarget>
{
public:
    UnarchiveTarget& archive(const std::string& a);

    // Target interface
    std::shared_ptr<class BuiltTarget> build( ContextPlan& ctx ) override;
    bool is_configuration_sensitive() const override {return false;}

private:
    std::string m_archive;
};


class CustomTarget : public Target_BaseDefinition<CustomTarget>
{
public:
    CustomTarget& custom_build(std::function<std::shared_ptr<class BuiltTarget>(ContextPlan&,Target_Base&)> buildMethod);
    CustomTarget& configuration_sensitive( bool e );


    // Target interface
    std::shared_ptr<class BuiltTarget> build( ContextPlan& ctx ) override;
    bool is_configuration_sensitive() const override {return m_configurationSensitive;}

private:
    std::function<std::shared_ptr<class BuiltTarget>(ContextPlan&,Target_Base&)> m_buildMethod;
    bool m_configurationSensitive = true;
};

